<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="..\CommonT4.tt" #>
using System;
using Xunit;

namespace Linq2d.Tests
{
	public class Coverage
	{
		[Fact]
		public void CoverageTest1arg1result()
		{
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
				from x in source
				select x+0;
			var r = q.ToArray();
			TestHelper.AssertEqual(source, r);
		}

		[Fact]
		public void CoverageTest1arg2results()
		{
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
				from x in source
				select ValueTuple.Create(x+0, x+0);
			var (r1, r2) = q.ToArrays();
			TestHelper.AssertEqual(source, r1);
			TestHelper.AssertEqual(source, r2);
		}
<#
for(int k=1; k<=maxRes; k++)
{
#>
		#region <#=k#> <#= Plural("result", k)#>
<#
	for(int n=1; n<=maxArg; n++)
	{
#>
		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
		for(int s=1; s<=n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
#>
				select <#= ReturnValueTuple(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>
			q = 
<#
		for(int s=1; s<=n; s++)
		{
#>
				from x<#=s#> in source<#= s==n?".With(0)":""#>
<#
		}
#>
				select <#= ReturnValueTuple(n, k)#>;
			<#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>
			var q2 = 
<#
		for(int s=1; s<=n; s++)
		{
#>
				from x<#=s#> in source<#= s==n?".With(0)":""#>
<#
		}
#>
				let y = <#= ChainSources(n)#>
				select <#= ReturnValueTupleWithY(n, k)#>;
			<#= Tuple("r", k)#> = q2.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>

		}

<#
		for(int r=1; r<=k; r++)
		{
#>
		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>WithRecurrence<#=r#>()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
		for(int s=1; s<=n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
		for(int s=1; s<=r; s++)
		{
#>
				from z<#=s#> in Result.InitWith(0)
<#
		}
#>
				select <#= ReturnValueTuple(n, k, ChainVars(r, "z", "[-1, -1]")+" + ")#>;

			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>

			var q1 = 
<#
		for(int s=1; s<=n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
		for(int s=1; s<=r; s++)
		{
#>
				from z<#=s#> in Result.InitWith(0)
<#
		}
#>
				let y = <#= ChainSources(n)#>
				select <#= ReturnValueTupleWithY(n, k, ChainVars(r, "z", "[-1, -1]")+" + ")#>;

			<#= Tuple("r", k)#> = q1.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>		}
<#
		} // r
#>

<#
	} // n
#>		#endregion

<#
} // k
#>
	}
}
<#+
	private static string ReturnValueTupleWithY(int n, int k, string prefix="") => ReturnValueTuple(n, k, prefix + "0*y + ");
	private static string ReturnValueTuple(int n, int k, string prefix="") => 
		k == 1 ? ChainSources(n, prefix) : "ValueTuple.Create(" + string.Join(", ", Enumerable.Repeat(ChainSources(n, prefix), k))+")";
	private static string ChainSources(int n, string prefix="") => prefix + ChainVars(n, "x");
	private static string ChainVars(int n, string name, string suffix="") => string.Join(" + ", Enumerable.Range(1,n).Select(i=>"0*"+name+i.ToString()+suffix));
#>