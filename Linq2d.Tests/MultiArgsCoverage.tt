<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="..\CommonT4.tt" #>
using System;
using Xunit;

namespace Linq2d.Tests
{
	public class MultiArgsCoverage
	{
<#
for(int k=1; k<=maxRes; k++)
{
#>
		#region <#=k#> <#= Plural("result", k)#>

		[Fact]
		public void Test2ArgsWrapped<#=k#><#=Plural("Result",k)#>()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
				from x1 in source.With(0)
				from x2 in source
				select <#= ReturnValueTuple(2, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>
			q = 
				from x1 in source.With(0)
				from x2 in source.With(0)
				select <#= ReturnValueTuple(2, k)#>;
			<#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>
			var q2 = 
				from x1 in source.With(0)
				from x2 in source
				let y = <#= ChainSources(2)#>
				select <#= ReturnValueTupleWithY(2, k)#>;
			<#= Tuple("r", k)#> = q2.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>

		}

<#
	for(int n=1; n<=maxArg; n++)
	{
#>

		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
		for(int s=1; s<n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
#>
				from x<#=n#> in source
				select <#= ReturnValueTuple(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>
		}

		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>WithVariable()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
		for(int s=1; s<n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
#>
				from x<#=n#> in source
				let y = <#= ChainSources(n)#>
				select <#= ReturnValueTupleWithY(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>

		}
<#
		if(n>1)
		{
#>
		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>VariableWith()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
			for(int s=1; s<n; s++)
			{
#>
				from x<#=s#> in source
<#
			}
#>
				let y = <#= ChainSources(n-1)#>
				from x<#=n#> in source
				select <#= ReturnValueTupleWithY(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
			for(int s=1; s<=k; s++)
			{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
			} // s
#>
		}
		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>VariableWithWrapped()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
			for(int s=1; s<n; s++)
			{
#>
				from x<#=s#> in source
<#
			}
#>
				let y = <#= ChainSources(n-1)#>
				from x<#=n#> in source.With(0)
				select <#= ReturnValueTupleWithY(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
			for(int s=1; s<=k; s++)
			{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
			} // s
#>
		}
<#
		} // if n > 1 
#>

		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>WrappedWithVariable()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
		for(int s=1; s<n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
#>
				from x<#=n#> in source.With(0)
				let y = <#= ChainSources(n)#>
				select <#= ReturnValueTupleWithY(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		}
#>

		}		[Fact]
		public void Test<#=n#><#=Plural("Arg",n)#><#=k#><#=Plural("Result",k)#>Wrapped()
		{
			var expect = ArrayHelper.InitAll(5, 5, 0);
			var source = ArrayHelper.InitAllRand(5, 5, 42);
			var q = 
<#
		for(int s=1; s<n; s++)
		{
#>
				from x<#=s#> in source
<#
		}
#>
				from x<#=n#> in source.With(0)
				select <#= ReturnValueTuple(n, k)#>;
			var <#= Tuple("r", k)#> = q.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		} //s
#>
			var q2 = 
<#
		for(int s=1; s<=n; s++)
		{
#>
				from x<#=s#> in source<#= s==n?".With(0)":""#>
<#
		} //s
#>
				let y = <#= ChainSources(n)#>
				select <#= ReturnValueTupleWithY(n, k)#>;
			<#= Tuple("r", k)#> = q2.<#= ToArrays(k)#>();
<#
		for(int s=1; s<=k; s++)
		{
#>
			TestHelper.AssertEqual(expect, r<#= k > 1 ? s : ""#>);
<#
		} //s
#>

		}

<#
	} // n
#>		#endregion

<#
} // k
#>
	}
}
<#+
	private static string ReturnValueTupleWithY(int n, int k, string prefix="") => ReturnValueTuple(n, k, prefix + "0*y + ");
	private static string ReturnValueTuple(int n, int k, string prefix="") => 
		k == 1 ? ChainSources(n, prefix) : "ValueTuple.Create(" + string.Join(", ", Enumerable.Repeat(ChainSources(n, prefix), k))+")";
	private static string ChainSources(int n, string prefix="") => prefix + ChainVars(n, "x");
	private static string ChainVars(int n, string name, string suffix="") => string.Join(" + ", Enumerable.Range(1,n).Select(i=>"0*"+name+i.ToString()+suffix));
#>