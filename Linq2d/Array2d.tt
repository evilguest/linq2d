<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\CommonT4.tt" #>
using System;
using System.Linq.Expressions;

namespace Linq2d
{
    public static class Array2d
    {
        #region control
        public static bool TryVectorize { get; set; } = true;
        public static bool EliminateCommonSubexpressions { get; set; } = true;
        public static bool PoolCSEVariables { get; set; } = true;
        public static bool SaveDynamicCode { get; set; } = false;
        public static bool MoveLoopInvariants {get; set; } = true;
        #endregion

        #region window functions
//        public static (Cell<T> tl, Cell<T> tr, Cell<T> bl, Cell<T> br) Window<T>(this Cell<T> cell, int size)
//            =>(cell, cell, cell, cell);
//        public static int Area<T>(this (Cell<T> tl, Cell<T> tr, Cell<T> bl, Cell<T> br) window)=>(window.br.X - window.tl.X) * (window.br.Y - window.tl.Y);
        
        #endregion



        #region Two arrays one result recurrent 
        public static IArrayTransform<T1, T2, R> SelectMany<T1, T2, _, R>(this IArrayQuery<T1, T2, _> source, Func<object, Result<R>> recurrentResultSelector, Expression<Func<_, RelativeCell<R>, R>> resultSelector)
            => new ArrayQuery<T1, T2, R>(source, recurrentResultSelector(default).InitValue, resultSelector);
        #endregion

        #region Three arrays 

        public static IArrayTransform<T1, T2, T3, R> SelectMany<T1, T2, T3, _, R>(this IArrayQuery<T1, T2, T3, _> source, Func<object, Result<R>> recurrentResultSelector, Expression<Func<_, RelativeCell<R>, R>> resultSelector)
            => new ArrayQuery<T1, T2, T3, R>(source, recurrentResultSelector(default).InitValue, resultSelector);

        public static IArrayQueryRecurrent<T1, T2, T3, A, R1> SelectMany<T1, T2, T3, _, A, R1>(this IArrayQuery<T1, T2, T3, _> source, Func<object, Result<R1>> recurrentResultSelector, Expression<Func<_, RelativeCell<R1>, A>> resultSelector)
            where A: class
            => new ArrayQueryRecurrent<T1, T2, T3, A, R1>(source, recurrentResultSelector(default).InitValue, resultSelector);

        #endregion

        #region 4 arrays 
        public static IArrayTransform<T1, T2, T3, T4, R> SelectMany<T1, T2, T3, T4, _, R>(this IArrayQuery<T1, T2, T3, T4, _> source, Func<object, Result<R>> recurrentResultSelector, Expression<Func<_, RelativeCell<R>, R>> resultSelector)
            => new ArrayQuery<T1, T2, T3, T4, R>(source, recurrentResultSelector(default).InitValue, resultSelector);

        public static IArrayQueryRecurrent<T1, T2, T3, T4, A, R1> SelectMany<T1, T2, T3, T4, _, A, R1>(this IArrayQuery<T1, T2, T3, T4, _> source, Func<object, Result<R1>> recurrentResultSelector, Expression<Func<_, RelativeCell<R1>, A>> resultSelector)
            where A: class
            => new ArrayQueryRecurrent<T1, T2, T3, T4, A, R1>(source, recurrentResultSelector(default).InitValue, resultSelector);

        #endregion


        #region Two array two results recurent two
        public static IArrayQueryRecurrent<T1, T2, A, R> SelectMany<T1, T2, _, A, R>(this IArrayQuery<T1, T2, _> source, Func<object, Result<R>> recurrentResultSelector, Expression<Func<_, RelativeCell<R>, A>> resultSelector)
            where A: class
            => new ArrayQueryRecurrent<T1, T2, A, R>(source, recurrentResultSelector(default).InitValue, resultSelector);
        #endregion


<#
for(int n=1; n<=maxArg; n++)
{
#>

        #region <#= n#> <#= Plural("array", n)#>

<#
for(int k=1; k<=maxRes; k++)
{
#>
        #region <#= n#> <#= Plural("array", n)#>, <#= k#> <#= Plural("result", k)#>

<#
    if(n==1)
    {
#>

        public static I<#= ArrayQueryRecurrentA(n, k)#> SelectMany<#=TemplateArgsSkipBase(n, k, "A")#>(this T[,] source, Func<object, Result<R<#=k>1?1:""#>>> secondSelector, Expression<Func<Cell<T>, RelativeCell<R<#=k>1?1:""#>>, A>> resultSelector)
        where A: class
            => new <#= ArrayQueryRecurrentA(n, k)#>(source.Wrap(), secondSelector(default).InitValue, resultSelector);
        public static I<#= ArrayQueryRecurrentA(n, k)#> SelectMany<#=TemplateArgsSkipBase(n, k, "A")#>(this ArraySource<T> source, Func<object, Result<R<#=k>1?1:""#>>> secondSelector, Expression<Func<Cell<T>, RelativeCell<R<#=k>1?1:""#>>, A>> resultSelector)
        where A: class
            => new <#= ArrayQueryRecurrentA(n, k)#>(source, secondSelector(default).InitValue, resultSelector);

        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this T[,] source, Func<object, Result<R<#= k>1?1:""#>>> recurrentResult1Selector, Expression<Func<Cell<T>, RelativeCell<R<#= k>1?1:""#>>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), recurrentResult1Selector(default).InitValue, resultSelector);
        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this ArraySource<T> source, Func<object, Result<R<#= k>1?1:""#>>> recurrentResult1Selector, Expression<Func<Cell<T>, RelativeCell<R<#= k>1?1:""#>>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source, recurrentResult1Selector(default).InitValue, resultSelector);

<#
        if(k==1)
        {
#>

        //  n=<#= n#> k=<#= k#> 
        public static <#= TypeName("IArrayQuery", n, k)#> Select<#= TemplateArgs(n, k)#>(this T[,] source, Expression<Func<Cell<T>, R>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), resultSelector);
        public static <#= TypeName("IArrayQuery", n, k)#> Select<#= TemplateArgs(n, k)#>(this ArraySource<T> source, Expression<Func<Cell<T>, R>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source, resultSelector);


<#
        } else
        {
#>
//****
//        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this IArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#> source, Func<object, Result<R<#=k#>>> recurrentSelector, Expression<Func<_, RelativeCell<R<#=k#>>, (R1, R2)>> resultSelector) 
//            => new <#= TypeName("ArrayQuery", n, k)#>(source, recurrentSelector(default).InitValue, resultSelector);
        public static <#= TypeName("IArrayTransform", n, k)#> Select<#= TemplateArgs(n, k)#>(this T[,] source, Expression<Func<Cell<T>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), resultSelector);
        public static <#= TypeName("IArrayTransform", n, k)#> Select<#= TemplateArgs(n, k)#>(this ArraySource<T> source, Expression<Func<Cell<T>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source, resultSelector);

        public static IArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this T[,] source, Func<object, Result<R<#= k>1?1:""#>>> recurrentResult1Selector, Expression<Func<Cell<T>, RelativeCell<R<#= k>1?1:""#>>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new ArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#>(source.Wrap(), recurrentResult1Selector(default).InitValue, resultSelector);
        public static IArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this ArraySource<T> source, Func<object, Result<R<#= k>1?1:""#>>> recurrentResult1Selector, Expression<Func<Cell<T>, RelativeCell<R<#= k>1?1:""#>>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new ArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#>(source, recurrentResult1Selector(default).InitValue, resultSelector);
        
<#
        } 
#>
<#
    }
#>
<#
    if(k==1)
    {
#>
        public static <#= TypeName("IArrayQuery", n, k)#> Select<#= TemplateArgsSkip(n, k)#>(this IArrayQuery<#= TemplateArgsSkip(n, 0)#> source, Expression<Func<_, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, resultSelector);
<#
    } else {
#>
        public static <#= TypeName("IArrayTransform", n, k)#> Select<#= TemplateArgsSkip(n, k)#>(this IArrayQuery<#= TemplateArgsSkip(n, 0)#> source, Expression<Func<_, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, resultSelector);
<#
    }
    if(n==2)
    {
        if(k==1)
        {
#>
        public static <#= TypeName("IArrayQuery", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this T1[,] source, Func<object, T2[,]> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), source<#= n#>Selector(default).Wrap(), resultSelector);
        public static <#= TypeName("IArrayQuery", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this T1[,] source, Func<object, ArraySource<T2>> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>,  <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), source<#= n#>Selector(default), resultSelector);
        public static <#= TypeName("IArrayQuery", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this ArraySource<T1> source, Func<object, T2[,]> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source, source<#= 2#>Selector(default).Wrap(), resultSelector);
        public static <#= TypeName("IArrayQuery", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this ArraySource<T1> source, Func<object, ArraySource<T2>> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, source<#= 2#>Selector(default), resultSelector);

<#
        } else {
#>
        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this T1[,] source, Func<object, T2[,]> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), source<#= n#>Selector(default).Wrap(), resultSelector);
        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this T1[,] source, Func<object, ArraySource<T2>> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>,  <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source.Wrap(), source<#= n#>Selector(default), resultSelector);
        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this ArraySource<T1> source, Func<object, T2[,]> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source, source<#= 2#>Selector(default).Wrap(), resultSelector);
        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgs(n, k)#>(this ArraySource<T1> source, Func<object, ArraySource<T2>> source<#= 2#>Selector, Expression<Func<Cell<T1>, Cell<T2>, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, source<#= 2#>Selector(default), resultSelector);

<#
        }
    }
#>

<#
    if(n>1)
    {
#>
        public static <#= TypeName("IArrayQuery", n, k)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this IArrayQuery<#= TemplateArgsSkipOne(n-1, 0)#> source, Func<object, T<#= n>1?n:""#>[,]> source<#= n#>Selector, Expression<Func<_, Cell<T<#= n>1?n:""#>>, <#= ReturnTuple(k)#>>> kernel)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, source<#= n#>Selector(default).Wrap(), kernel);

        public static <#= TypeName("IArrayQuery", n, k)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this IArrayQuery<#= TemplateArgsSkipOne(n-1, 0)#> source, Func<object, ArraySource<T<#= n>1?n:""#>>> source<#= n#>Selector, Expression<Func<_, Cell<T<#= n>1?n:""#>>, <#= ReturnTuple(k)#>>> kernel)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, source<#= n#>Selector(default), kernel);

<#
    }
    if(k==1)
    {
#>
<#
    } else //(k>1)
    {
#>
///@@@
<#
        for(int l=2; l<=k;l++)
        {
#>
        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this IArrayQueryRecurrent<#=l>2?l-1:""#><#= TemplateArgsSkipTwo(n, l-1)#> source, Func<object, Result<R<#=l#>>> recurrentSelector, Expression<Func<_, RelativeCell<R<#=l#>>, <#= ReturnTuple(k)#>>> resultSelector) 
            => new <#= TypeName("ArrayQuery", n, k)#>(source, recurrentSelector(default).InitValue, resultSelector);
        // n=<#=n#> k=<#=k#> l=<#=l#> <T, _, A, R1, R2>

<#
        }
#>
        public static I<#= ArrayQueryRecurrentA(n, k)#> SelectMany<#= TemplateArgsSkipBase(n, k, "_, A")#>(this IArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#> source, Func<object, Result<R<#=k#>>> secondSelector, Expression<Func<_, RelativeCell<R<#=k#>>, A>> resultSelector) 
            where A: class
            => new <#= ArrayQueryRecurrentA(n, k)#>(source, secondSelector(default).InitValue, resultSelector);

        public static <#= TypeName("IArrayTransform", n, k)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this IArrayQuery<#= TemplateArgsSkip(n, 0)#> source, Func<object, Result<R<#= k>1?1:""#>>> recurrentResult1Selector, Expression<Func<_, RelativeCell<R<#= k>1?1:""#>>, <#= ReturnTuple(k)#>>> resultSelector)
            => new <#= TypeName("ArrayQuery", n, k)#>(source, recurrentResult1Selector(default).InitValue, resultSelector);


//        public static IArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#> SelectMany<#= TemplateArgsSkip(n, k)#>(this IArrayQuery<#= TemplateArgsSkip(n, 0)#> source, Func<object, Result<R<#= k>1?1:""#>>> recurrentResult1Selector, Expression<Func<_, RelativeCell<R<#= k>1?1:""#>>, <#= ReturnTuple(k)#>>> resultSelector)
//            => new ArrayQueryRecurrent<#=k>2?k-1:""#><#= TemplateArgsSkipTwo(n, k-1)#>(source, recurrentResult1Selector(default).InitValue, resultSelector);
<#
    }
#>
        #endregion

<#
}
#>
        #endregion
<#
}
#>

        public static ArraySource<T> With<T>(this T[,] source, T initValue) => new ArraySource<T>(source, initValue);
        public static ArraySource<T> With<T>(this T[,] source, OutOfBoundsStrategy<T> strategy) => new ArraySource<T>(source, strategy);
        public static ArraySource<T> With<T>(this T[,] source, OutOfBoundsStrategyUntyped strategy) => new ArraySource<T>(source, strategy);
    }

}